query: "with recursive /* pgwatch_generated */\n    q_root_part as (\n        select\
  \ c.oid,\n               c.relkind,\n               n.nspname root_schema,\n   \
  \            c.relname root_relname\n        from pg_class c\n                 join\
  \ pg_namespace n on n.oid = c.relnamespace\n        where relkind in ('p', 'r')\n\
  \          and relpersistence != 't'\n          and not n.nspname like any (array[E'pg\\\
  \\_%', 'information_schema', E'\\\\_timescaledb%'])\n          and not exists(select\
  \ * from pg_inherits where inhrelid = c.oid)\n          and exists(select * from\
  \ pg_inherits where inhparent = c.oid)\n    ),\n    q_parts (relid, relkind, level,\
  \ root) as (\n        select oid, relkind, 1, oid\n        from q_root_part\n  \
  \      union all\n        select inhrelid, c.relkind, level + 1, q.root\n      \
  \  from pg_inherits i\n                 join q_parts q on inhparent = q.relid\n\
  \                 join pg_class c on c.oid = i.inhrelid\n    ),\n    q_tstats as\
  \ (\n        select (extract(epoch from now()) * 1e9)::int8                    \
  \                              as epoch_ns,\n               relid, -- not sent to\
  \ final output\n               quote_ident(schemaname)                         \
  \                                         as tag_schema,\n               quote_ident(ut.relname)\
  \                                                                  as tag_table_name,\n\
  \               quote_ident(schemaname) || '.' || quote_ident(ut.relname)      \
  \                          as tag_table_full_name,\n               pg_table_size(relid)\
  \                                                                     as table_size_b,\n\
  \               abs(greatest(ceil(log((pg_table_size(relid) + 1) / 10 ^ 6)), 0))::text\
  \                   as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n\
  \               pg_total_relation_size(relid)                                  \
  \                          as total_relation_size_b,\n               case when reltoastrelid\
  \ != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n\
  \               (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8\
  \               as seconds_since_last_vacuum,\n               (extract(epoch from\
  \ now() - greatest(last_analyze, last_autoanalyze)))::int8             as seconds_since_last_analyze,\n\
  \               case when 'autovacuum_enabled=off' = ANY (c.reloptions) then 1 else\
  \ 0 end                as no_autovacuum,\n               seq_scan,\n           \
  \    seq_tup_read,\n               coalesce(idx_scan, 0) as idx_scan,\n        \
  \       coalesce(idx_tup_fetch, 0) as idx_tup_fetch,\n               n_tup_ins,\n\
  \               n_tup_upd,\n               n_tup_del,\n               n_tup_hot_upd,\n\
  \               n_live_tup,\n               n_dead_tup,\n               vacuum_count,\n\
  \               autovacuum_count,\n               analyze_count,\n             \
  \  autoanalyze_count,\n               case when c.relkind != 'p' then age(c.relfrozenxid)\
  \ else 0 end as tx_freeze_age\n        from pg_stat_user_tables ut\n           \
  \      join\n             pg_class c on c.oid = ut.relid\n        where\n      \
  \    -- leaving out fully locked tables as pg_relation_size also wants a lock and\
  \ would wait\n            not exists(select 1 from pg_locks where relation = relid\
  \ and mode = 'AccessExclusiveLock')\n          and c.relpersistence != 't' -- and\
  \ temp tables\n    )\nselect\n    epoch_ns,\n    tag_schema,\n    tag_table_name,\n\
  \    tag_table_full_name,\n    0 as is_part_root,\n    table_size_b,\n    tag_table_size_cardinality_mb,\
  \ -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n    total_relation_size_b,\n    toast_size_b,\n\
  \    seconds_since_last_vacuum,\n    seconds_since_last_analyze,\n    no_autovacuum,\n\
  \    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n\
  \    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_live_tup,\n    n_dead_tup,\n\
  \    vacuum_count,\n    autovacuum_count,\n    analyze_count,\n    autoanalyze_count,\n\
  \    tx_freeze_age\nfrom q_tstats\nwhere not tag_schema like E'\\\\_timescaledb%'\n\
  and not exists (select * from q_root_part where oid = q_tstats.relid)\n\nunion all\n\
  \nselect * from (\n    select\n        epoch_ns,\n        quote_ident(qr.root_schema)\
  \ as tag_schema,\n        quote_ident(qr.root_relname) as tag_table_name,\n    \
  \    quote_ident(qr.root_schema) || '.' || quote_ident(qr.root_relname) as tag_table_full_name,\n\
  \        1 as is_part_root,\n        sum(table_size_b)::int8 table_size_b,\n   \
  \     abs(greatest(ceil(log((sum(table_size_b) + 1) / 10 ^ 6)),\n             0))::text\
  \ as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n     \
  \   sum(total_relation_size_b)::int8 total_relation_size_b,\n        sum(toast_size_b)::int8\
  \ toast_size_b,\n        min(seconds_since_last_vacuum)::int8 seconds_since_last_vacuum,\n\
  \        min(seconds_since_last_analyze)::int8 seconds_since_last_analyze,\n   \
  \     sum(no_autovacuum)::int8 no_autovacuum,\n        sum(seq_scan)::int8 seq_scan,\n\
  \        sum(seq_tup_read)::int8 seq_tup_read,\n        sum(idx_scan)::int8 idx_scan,\n\
  \        sum(idx_tup_fetch)::int8 idx_tup_fetch,\n        sum(n_tup_ins)::int8 n_tup_ins,\n\
  \        sum(n_tup_upd)::int8 n_tup_upd,\n        sum(n_tup_del)::int8 n_tup_del,\n\
  \        sum(n_tup_hot_upd)::int8 n_tup_hot_upd,\n        sum(n_live_tup)::int8\
  \ n_live_tup,\n        sum(n_dead_tup)::int8 n_dead_tup,\n        sum(vacuum_count)::int8\
  \ vacuum_count,\n        sum(autovacuum_count)::int8 autovacuum_count,\n       \
  \ sum(analyze_count)::int8 analyze_count,\n        sum(autoanalyze_count)::int8\
  \ autoanalyze_count,\n        max(tx_freeze_age)::int8 tx_freeze_age\n      from\n\
  \           q_tstats ts\n           join q_parts qp on qp.relid = ts.relid\n   \
  \        join q_root_part qr on qr.oid = qp.root\n      group by\n           1,\
  \ 2, 3, 4\n) x\norder by table_size_b desc nulls last limit 300"
metrics:
- name: table_size_b
  type: gauge
- name: total_relation_size_b
  type: gauge
- name: toast_size_b
  type: gauge
- name: seconds_since_last_vacuum
  type: gauge
- name: seconds_since_last_analyze
  type: gauge
- name: n_live_tup
  type: gauge
- name: n_dead_tup
  type: gauge
