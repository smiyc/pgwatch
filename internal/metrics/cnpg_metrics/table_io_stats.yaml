query: "select * from ( /* pgwatch_generated */\n      with recursive\n          q_root_part\
  \ as (\n                select c.oid,\n                        c.relkind,\n    \
  \                    n.nspname root_schema,\n                        c.relname root_relname\n\
  \                from pg_class c\n                          join pg_namespace n\
  \ on n.oid = c.relnamespace\n                where relkind in ('p', 'r')\n     \
  \             and relpersistence != 't'\n                  and not n.nspname like\
  \ any (array[E'pg\\\\_%', 'information_schema', E'\\\\_timescaledb%'])\n       \
  \           and not exists(select * from pg_inherits where inhrelid = c.oid)\n \
  \                 and exists(select * from pg_inherits where inhparent = c.oid)\n\
  \          ),\n          q_parts (relid, relkind, level, root) as (\n          \
  \    select oid, relkind, 1, oid\n              from q_root_part\n             \
  \ union all\n              select inhrelid, c.relkind, level + 1, q.root\n     \
  \         from pg_inherits i\n                        join q_parts q on inhparent\
  \ = q.relid\n                        join pg_class c on c.oid = i.inhrelid\n   \
  \       ),\n          q_tstats as (\n              SELECT (extract(epoch from now())\
  \ * 1e9)::int8                as epoch_ns,\n                      relid,\n     \
  \                 schemaname::text                                       as tag_schema,\n\
  \                      relname::text                                          as\
  \ tag_table_name,\n                      quote_ident(schemaname) || '.' || quote_ident(relname)\
  \ as tag_table_full_name,\n                      heap_blks_read,\n             \
  \         heap_blks_hit,\n                      idx_blks_read,\n               \
  \       idx_blks_hit,\n                      toast_blks_read,\n                \
  \      toast_blks_hit,\n                      tidx_blks_read,\n                \
  \      tidx_blks_hit\n              FROM pg_statio_user_tables\n              WHERE\
  \ NOT schemaname LIKE E'pg\\\\_temp%'\n                AND (heap_blks_read > 0 OR\
  \ heap_blks_hit > 0 OR idx_blks_read > 0 OR idx_blks_hit > 0 OR\n              \
  \        tidx_blks_read > 0 OR\n                      tidx_blks_hit > 0)\n     \
  \     )\n      select epoch_ns,\n              tag_schema,\n              tag_table_name,\n\
  \              tag_table_full_name,\n              0 as is_part_root,\n        \
  \      heap_blks_read,\n              heap_blks_hit,\n              idx_blks_read,\n\
  \              idx_blks_hit,\n              toast_blks_read,\n              toast_blks_hit,\n\
  \              tidx_blks_read,\n              tidx_blks_hit\n      from q_tstats\n\
  \      where not tag_schema like E'\\\\_timescaledb%'\n      and not exists (select\
  \ * from q_root_part where oid = q_tstats.relid)\n\n      union all\n\n      select\
  \ *\n      from (\n                select epoch_ns,\n                      quote_ident(qr.root_schema)\
  \                                        as tag_schema,\n                      quote_ident(qr.root_relname)\
  \                                       as tag_table_name,\n                   \
  \   quote_ident(qr.root_schema) || '.' || quote_ident(qr.root_relname) as tag_table_full_name,\n\
  \                      1                                                       \
  \           as is_part_root,\n                      sum(heap_blks_read)::int8,\n\
  \                      sum(heap_blks_hit)::int8,\n                      sum(idx_blks_read)::int8,\n\
  \                      sum(idx_blks_hit)::int8,\n                      sum(toast_blks_read)::int8,\n\
  \                      sum(toast_blks_hit)::int8,\n                      sum(tidx_blks_read)::int8,\n\
  \                      sum(tidx_blks_hit)::int8\n                from q_tstats ts\n\
  \                        join q_parts qp on qp.relid = ts.relid\n              \
  \          join q_root_part qr on qr.oid = qp.root\n                group by 1,\
  \ 2, 3, 4\n            ) x\n  ) y\norder by\n  coalesce(heap_blks_read, 0) +\n \
  \ coalesce(heap_blks_hit, 0) +\n  coalesce(idx_blks_read, 0) +\n  coalesce(idx_blks_hit,\
  \ 0) +\n  coalesce(toast_blks_read, 0) +\n  coalesce(toast_blks_hit, 0) +\n  coalesce(tidx_blks_read,\
  \ 0) +\n  coalesce(tidx_blks_hit, 0)\n  desc limit 300"
metrics: []
