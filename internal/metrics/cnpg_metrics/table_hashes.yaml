query: "select /* pgwatch_generated */\n  (extract(epoch from now()) * 1e9)::int8\
  \ as epoch_ns,\n  quote_ident(table_schema)||'.'||quote_ident(table_name) as tag_table,\n\
  \  md5((array_agg((c.*)::text order by ordinal_position))::text)\nfrom (\n SELECT\
  \ current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier\
  \ AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n\
  \    a.attname::information_schema.sql_identifier AS column_name,\n    a.attnum::information_schema.cardinal_number\
  \ AS ordinal_position,\n    pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data\
  \ AS column_default,\n        CASE\n            WHEN a.attnotnull OR t.typtype =\
  \ 'd'::\"char\" AND t.typnotnull THEN 'NO'::text\n            ELSE 'YES'::text\n\
  \        END::information_schema.yes_or_no AS is_nullable,\n        CASE\n     \
  \       WHEN t.typtype = 'd'::\"char\" THEN\n            CASE\n                WHEN\
  \ bt.typelem <> 0::oid AND bt.typlen = '-1'::integer THEN 'ARRAY'::text\n      \
  \          WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype,\
  \ NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n \
  \           ELSE\n            CASE\n                WHEN t.typelem <> 0::oid AND\
  \ t.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nt.nspname =\
  \ 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)\n             \
  \   ELSE 'USER-DEFINED'::text\n            END\n        END::information_schema.character_data\
  \ AS data_type,\n    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number\
  \ AS character_maximum_length,\n    information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number\
  \ AS character_octet_length,\n    information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number\
  \ AS numeric_precision,\n    information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number\
  \ AS numeric_precision_radix,\n    information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number\
  \ AS numeric_scale,\n    information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number\
  \ AS datetime_precision,\n    information_schema._pg_interval_type(information_schema._pg_truetypid(a.*,\
  \ t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data\
  \ AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n\
  \    NULL::character varying::information_schema.sql_identifier AS character_set_catalog,\n\
  \    NULL::character varying::information_schema.sql_identifier AS character_set_schema,\n\
  \    NULL::character varying::information_schema.sql_identifier AS character_set_name,\n\
  \        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n\
  \            ELSE NULL::name\n        END::information_schema.sql_identifier AS\
  \ collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n\
  \    co.collname::information_schema.sql_identifier AS collation_name,\n       \
  \ CASE\n            WHEN t.typtype = 'd'::\"char\" THEN current_database()\n   \
  \         ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_catalog,\n\
  \        CASE\n            WHEN t.typtype = 'd'::\"char\" THEN nt.nspname\n    \
  \        ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_schema,\n\
  \        CASE\n            WHEN t.typtype = 'd'::\"char\" THEN t.typname\n     \
  \       ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_name,\n\
  \    current_database()::information_schema.sql_identifier AS udt_catalog,\n   \
  \ COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,\n\
  \    COALESCE(bt.typname, t.typname)::information_schema.sql_identifier AS udt_name,\n\
  \    NULL::character varying::information_schema.sql_identifier AS scope_catalog,\n\
  \    NULL::character varying::information_schema.sql_identifier AS scope_schema,\n\
  \    NULL::character varying::information_schema.sql_identifier AS scope_name,\n\
  \    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n\
  \    a.attnum::information_schema.sql_identifier AS dtd_identifier,\n    'NO'::character\
  \ varying::information_schema.yes_or_no AS is_self_referencing,\n    'NO'::character\
  \ varying::information_schema.yes_or_no AS is_identity,\n    NULL::character varying::information_schema.character_data\
  \ AS identity_generation,\n    NULL::character varying::information_schema.character_data\
  \ AS identity_start,\n    NULL::character varying::information_schema.character_data\
  \ AS identity_increment,\n    NULL::character varying::information_schema.character_data\
  \ AS identity_maximum,\n    NULL::character varying::information_schema.character_data\
  \ AS identity_minimum,\n    NULL::character varying::information_schema.yes_or_no\
  \ AS identity_cycle,\n    'NEVER'::character varying::information_schema.character_data\
  \ AS is_generated,\n    NULL::character varying::information_schema.character_data\
  \ AS generation_expression,\n        CASE\n            WHEN c.relkind = 'r'::\"\
  char\" OR (c.relkind = ANY (ARRAY['v'::\"char\", 'f'::\"char\"])) AND pg_column_is_updatable(c.oid::regclass,\
  \ a.attnum, false) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no\
  \ AS is_updatable\n   FROM pg_attribute a\n     LEFT JOIN pg_attrdef ad ON a.attrelid\
  \ = ad.adrelid AND a.attnum = ad.adnum\n     JOIN (pg_class c\n     JOIN pg_namespace\
  \ nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid\n     JOIN (pg_type t\n \
  \    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid\n  \
  \   LEFT JOIN (pg_type bt\n     JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid)\
  \ ON t.typtype = 'd'::\"char\" AND t.typbasetype = bt.oid\n     LEFT JOIN (pg_collation\
  \ co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON a.attcollation\
  \ = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n\
  \  WHERE NOT pg_is_other_temp_schema(nc.oid) AND a.attnum > 0 AND NOT a.attisdropped\
  \ AND (c.relkind = ANY (ARRAY['r'::\"char\", 'v'::\"char\", 'f'::\"char\"]))\n\n\
  ) c\nwhere\n  not table_schema like any (array[E'pg\\\\_%', 'information_schema'])\n\
  group by\n  table_schema, table_name\norder by\n  table_schema, table_name"
metrics: []
